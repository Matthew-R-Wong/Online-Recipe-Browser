My code is broken up into four files: main.py, recipe.py, recipe_manager.py, and recipe_ui.py

main.py:
	Main.py is honestly just there to help show the file hierarchy order easily. It imports tkinter and the menu_manager class. It is the
	highest in the file hierarchy, and all it does is define the root frame window (The highest frame that all other frames go inside of), 
	run the menu_manager class (will explain effects later), and runs .mainloop(), which runs the program until the user exits out of the window.

recipe.py:
	Recipe.py contains the class called Recipe, which I use to define, create, and contain the information for each recipe. It stores the name,
	photo name, tags, ingredients, and description for each object. It just initializes each variable, and has another function to set the values.
	it is lowest on the hierarchy, and both recipe_manager and recipe_ui draw from it.

recipe_ui.py:
	Recipe_ui.py contains the bulk of the code, and is mainly used to set up the tkinter framing. It draws the Recipe class from recipe.py and
	the recipe_manager class from recipe_manager.py, and basically the entire program is contained within the menu_manager class. It initializes
	all of the main frames that will be used, loads the recipe list, and also initializes the following:
	
	Class Initialization:

	From recipe_manager:
		recipe_list: A list containing every recipe object
		all_tags: a list containing every unique tag from every recipe object in recipe_list

	Not from recipe_manager:
		recipe_menu: Creates a variable that will be later checked to see if the "Add Recipe" window already exists, or needs to be created
		tag_state: A dictionary that will be used to hold every tag, and its associated tag state (true or false). The tag state is a BooleanVar() variable,
				a new kind of tkinter variable that can be attached to a function call command any time they are changed.
		hold_true_tags: An empty string that will be later used to hold the list of recipe names that contain every true (selected) tag when sorting through
					recipes.
	
	It also sets up the interactable things in the main window, such as the combobox (drop-down selector) and the 3 buttons (add recipe, edit recipe, and delete
	recipe. The combobox also has a StringVar() variable that reads when a new drop down value has been chosen and calls to update the window with them name of 	the chosen recipe. Additionally, when pressed, the edit and delete recipe buttons will call to their respective functions with the information of whatever 	the currently chosen recipe is.

	Class Functions:
	
	The update window and clear display functions are used to either refresh the information shown, like when the description of an object is edited, or when 	the information just needs to be wiped, like when a recipe is deleted.	

	The new_recipe function checks to see if its window has already been created. If it has then it simply opens that window, and if it hasn't then it 
	creates the window. It makes a top level frame (opens another window instance), puts the text boxes inside to read information from, then waits for the
	use to press the submit recipe button at the bottom. Once pressed:
			1) The pair ingredients function turns them into a list of tuples, 
			2) The clear text boxes function clears the boxes for future runs
			3) The submit recipe button reads the information from the text boxes, appends a Recipe object with that info, hides the window, and updates
				everything (text file, drop-box values, tags, etc.).
	If the new recipe menu is closed by x-ing out of the window, it just clears the text boxes and hides the window.

	The edit recipe function acts almost identical to the new recipe function, and the framing actually is exactly the same. However, when called it fills the
	text boxes with whatever the stored information is for that Recipe variable, and then saves whatever is in the text boxes when the finished button is pressed
	
	The delete recipe function calls to recipe_manager to delete the currently chosen recipe object, and then updates the tags and windows and other required
	information.
	
	The toggle tags function is used to create the listbox (The menu where you can select specific tags to sort by). It does so by sorting through each unique
	tag from every recipe, and then giving each one a BooleanVar() variable. This acts basically exactly like StringVar, but its used as a Boolean instead of a
	string. Whenever a tag is chosen it updates the variable to True, and automatically calls to update tag list. Which creates a temporary array of every true
	tag, uses .join to turn the list into an array of tags separated by newlines, and then calls to the show tag list function. This is one of the coolest parts
	of the program, because it shows (at least to me) how you can use tkinter variables to auto update a menu whenever a tkinter Var variable changes.

	After the above functions the only other functions are the show_value functions for the sorted recipes, tags, ingredients, description, and photo.
	None of these are too complicated, and basically all consist of reading information in from a recipe and setting up frames and widgets to display the
	information. The only notable things done in them is using frame.winfo_children() to access all of the widget information in each frame and destroy it.
	If I did not do this then the frame creation would duplicate every time the function is run. 

recipe_manager.py:
	Recipe_manager.py contains the functions that interact with changing the actual recipe object values. I separated most of the recipe value management
	from the ui management to make the files more readable. Recipe manager draws from recipe.py, and is third in the higherarchy. The recipe_manager.py file
	is entirely contained within the recipe_manager class, and initializes and creates the following functions:

	Class Initialization:

	recipe_list: As said above, the recipe list is a list of all of the Recipe objects
	all_tags: As said above, all tags is a list of every tag present in every Recipe

	Class Functions:

	The add recipe function takes a Recipe object and appends it to the end of recipe list, then calls to update tags.

	The delete recipe function takes a recipe name and removes the Recipe object associated with that name, then calls to update tags.

	Update recipe takes the old Recipe object as well as the new values, sets the Recipe values to the new ones, then calls to update tags.

	The add subtract tags function takes a new string of tags, then checks to see if any new tags need to be added to all_tags, or old tags deleted from all_tags

	The update tags function takes the new and old tag lists, then checks and removes them from all_tags. It acts similarly to the add subtract tags function,
	but it is used for the edit recipe specifically.

	The load recipes function reads in from the text file, strips the file into a list based on every double newline, indexes through the list by 5 (every Recipe
	object has 5 parts), and applies the info from each part of the list into a Recipe object that is appended onto the recipe list.

	The save function opens the text file for writing, and then just writes the info in each Recipe object onto the text file in the correct format, where each
	object part is separated by a double newline.